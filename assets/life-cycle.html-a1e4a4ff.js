import{_ as l,M as r,p as i,q as a,R as e,t as o,N as c,a1 as d}from"./framework-96b046e1.js";const n={},u=d(`<h1 id="vue2-生命周期相关" tabindex="-1"><a class="header-anchor" href="#vue2-生命周期相关" aria-hidden="true">#</a> vue2 生命周期相关</h1><h3 id="vue-组件生命周期钩子" tabindex="-1"><a class="header-anchor" href="#vue-组件生命周期钩子" aria-hidden="true">#</a> vue <strong>组件生命周期钩子</strong></h3><ul><li>beforeCreated</li><li>created</li><li>beforeMounted</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>beforeDestroy</li><li>destroyed</li></ul><h3 id="vue-router" tabindex="-1"><a class="header-anchor" href="#vue-router" aria-hidden="true">#</a> vue-router</h3><p><code>beforeRouteEnter</code> // <strong>不能</strong>访问 this ，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p><p><code>beforeRouteUpdate</code> // 在当前路由改变，但是该组件被复用时调用</p><p><code>beforeRouteLeave</code> // 导航离开该组件的对应路由时调用</p><p>vue-router全局有三个守卫：</p><ol><li>router.beforeEach 全局前置守卫 进入路由之前</li><li>router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用</li><li>router.afterEach 全局后置钩子 进入路由之后</li></ol><h2 id="完整的导航解析流程" tabindex="-1"><a class="header-anchor" href="#完整的导航解析流程" aria-hidden="true">#</a> <strong>完整的导航解析流程</strong></h2><ol><li>导航被触发。</li><li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 。</li><li>在路由配置里调用 <code>beforeEnter</code> // 路由独享的守卫。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h3 id="keep-alive-组件" tabindex="-1"><a class="header-anchor" href="#keep-alive-组件" aria-hidden="true">#</a> keep-alive 组件</h3><p>可以接收3个属性做为参数进行匹配对应的组件进行缓存</p><ul><li>include包含的组件(可以为字符串，数组，以及正则表达式,只有匹配的组件会被缓存)</li><li>exclude排除的组件(以为字符串，数组，以及正则表达式,任何匹配的组件都不会被缓存)</li><li>max缓存组件的最大值(类型为字符或者数字,可以控制缓存组件的个数)</li></ul><p>被<code>keep-alive</code>包含的组件/路由中，会多出两个生命周期的钩子:<code>activated</code> 与 <code>deactivated</code>。</p><p><strong>activated在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用</strong></p><p><strong>再次进入缓存路由/组件时，不会触发这些钩子</strong></p><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code>beforeCreate created beforeMount mounted 都不会触发。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>deactivated：组件被停用(离开路由)时调用</strong></p><p><strong>使用了<code>keep-alive</code>就不会调用<code>beforeDestroy</code>(组件销毁前钩子)和<code>destroyed</code>(组件销毁)，因为组件没被销毁，被缓存起来了</strong>。</p><p>这个钩子可以看作<code>beforeDestroy</code>的替代，如果你缓存了组件，要在组件销毁的的时候做一些事情，你可以放在这个钩子里。</p><h3 id="vue指令的生命周期" tabindex="-1"><a class="header-anchor" href="#vue指令的生命周期" aria-hidden="true">#</a> vue指令的生命周期</h3><p>Vue2</p><p>自定义指令有五个生命周期（也叫钩子函数），分别是 bind,inserted,update,componentUpdated,unbind</p><ol><li>bind:只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。</li><li>inserted:被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。</li><li>update:被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。</li><li>componentUpdated:被绑定元素所在模板完成一次更新周期时调用。</li><li>unbind:只调用一次，指令与元素解绑时调用。</li></ol><p>Vue3</p><ol><li><code>created</code>：在绑定元素的 attribute 或事件监听器被应用之前调用。在指令需要附加在普通的 <code>v-on</code> 事件监听器调用前的事件监听器中时，这很有用。</li><li><code>beforeMount</code>：当指令第一次绑定到元素并且在挂载父组件之前调用。</li><li><code>mounted</code>：在绑定元素的父组件被挂载后调用。</li><li><code>beforeUpdate</code>：在更新包含组件的 VNode 之前调用。</li><li><code>updated</code>：在包含组件的 VNode <strong>及其子组件的 VNode</strong> 更新后调用。</li><li><code>beforeUnmount</code>：在卸载绑定元素的父组件之前调用</li><li><code>unmounted</code>：当指令与元素解除绑定且父组件已卸载时，只调用一次。</li></ol><p>指令的参数可以是动态的。例如，在 <code>v-mydirective:[argument]=&quot;value&quot;</code> 中，<code>argument</code> 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。</p><h3 id="触发钩子的完整顺序" tabindex="-1"><a class="header-anchor" href="#触发钩子的完整顺序" aria-hidden="true">#</a> 触发钩子的完整顺序</h3><p>将路由导航、<code>keep-alive</code>、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件：</p>`,30),s=e("li",null,[e("code",null,"beforeRouteLeave"),o(":路由组件的组件离开路由前钩子，可取消路由离开。")],-1),p=e("li",null,[e("code",null,"beforeEach"),o(": 路由全局前置守卫，可用于登录验证、全局路由loading等。")],-1),h=e("li",null,[e("code",null,"beforeEnter"),o(": 路由独享守卫")],-1),f=e("li",null,[e("code",null,"beforeRouteEnter"),o(": 路由组件的组件进入路由前钩子。")],-1),b=e("code",null,"beforeResolve",-1),v={href:"https://link.juejin.cn/?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2Fguide%2Fadvanced%2Fnavigation-guards.html%23%25E5%2585%25A8%25E5%25B1%2580%25E8%25A7%25A3%25E6%259E%2590%25E5%25AE%2588%25E5%258D%25AB",target:"_blank",rel:"noopener noreferrer"},g=d("<li><code>afterEach</code>:路由全局后置钩子</li><li><code>beforeCreate</code>:组件生命周期，不能访问<code>this</code>。</li><li><code>created</code>:组件生命周期，可以访问<code>this</code>，不能访问dom。</li><li><code>beforeMount</code>:组件生命周期</li><li><code>deactivated</code>: 离开缓存组件a，或者触发a的<code>beforeDestroy</code>和<code>destroyed</code>组件销毁钩子。</li><li><code>mounted</code>:访问/操作dom。</li><li><code>activated</code>:进入缓存组件，进入a的嵌套子组件(如果有的话)。</li><li>执行beforeRouteEnter回调函数next。</li>",8),_=d('<h3 id="父子组件生命周期顺序" tabindex="-1"><a class="header-anchor" href="#父子组件生命周期顺序" aria-hidden="true">#</a> 父子组件生命周期顺序</h3><ol><li>挂载阶段</li></ol><p>该过程主要涉及 beforeCreate()、created()、beforeMount()、mounted() 4 个钩子函数。执行顺序为：</p><p>父beforeCreate() -&gt; 父created() -&gt; 父beforeMount() -&gt; 子beforeCreate() -&gt; 子created() -&gt; 子beforeMount() -&gt; 子mounted() -&gt; 父mounted() 一定得等子组件挂载完毕后，父组件才能挂在完毕，所以父组件的 mounted 在最后。</p><ol start="2"><li>子组件更新阶段</li></ol><p>该过程主要涉及 beforeUpdate()、updated() 2 个钩子函数。注意，当父子组件有数据传递时，才有这个更新阶段执行顺序的比较。执行顺序为： 父beforeUpdate() -&gt; 子beforeUpdate() -&gt; 子updated() -&gt; 父updated()</p><ol start="3"><li>父组件更新过程</li></ol><p>父beforeUpdate() -&gt;父updated()</p><ol start="4"><li>销毁阶段</li></ol><p>该过程主要涉及beforeDestroy()、destroyed() 2 个钩子函数。执行顺序为： 父beforeDestroy() -&gt; 子beforeDestroy() -&gt; 子destroyed() -&gt; 父destroyed()</p><ol start="5"><li>Vue 父子组件生命周期钩子的执行顺序遵循：从外到内，再从内到外</li></ol>',11);function m(E,x){const t=r("ExternalLinkIcon");return i(),a("div",null,[u,e("ol",null,[s,p,h,f,e("li",null,[b,o(":"),e("a",v,[o("路由全局解析守卫"),c(t)])]),g]),_])}const R=l(n,[["render",m],["__file","life-cycle.html.vue"]]);export{R as default};
