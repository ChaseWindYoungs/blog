import{_ as r,M as c,p as t,q as n,R as e,t as s,N as i,a1 as a}from"./framework-96b046e1.js";const p="/blog/assets/cache-introduce-460a4c6c.png",d="/blog/assets/http-cache-flowchart-3200682d.png",l="/blog/assets/example1-33837849.png",h="/blog/assets/example2-733af1eb.png",b="/blog/assets/proxy-server-b92caf28.png",g="/blog/assets/negotiation-caching-6d48e31a.png",u="/blog/assets/example3-c1b896d9.png",m="/blog/assets/last-modified-249c2e39.png",x="/blog/assets/example4-7b320ba7.png",f="/blog/assets/example5-974f5bc9.png",_="/blog/assets/etag-process-cd55ec46.png",k={},E=a('<h2 id="什么是web缓存" tabindex="-1"><a class="header-anchor" href="#什么是web缓存" aria-hidden="true">#</a> 什么是Web缓存</h2><p>Web缓存主要指的是两部分：<code>浏览器缓存</code>和<code>http缓存</code>。这篇文章重点讲解的是：前端http缓存。</p><p>http缓存</p><blockquote><p>Web 缓存是可以自动保存常见文档副本的 HTTP 设备。当Web请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这个文档。</p></blockquote><p>举例：<br><img src="'+p+'" alt="image.png"></p><p>服务器需要处理http的请求，并且http去传输数据，需要带宽，带宽是要钱买的啊。而我们缓存，就是为了让服务器不去处理这个请求，客户端也可以拿到数据。</p><blockquote><p>我们的缓存主要是针对html,css,img等静态资源，常规情况下，我们不会去缓存一些动态资源，因为缓存动态资源的话，数据的实时性就不会不太好，所以我们一般都只会去缓存一些不太容易被改变的静态资源。</p></blockquote><h2 id="缓存可以解决什么问题-他的缺点是什么" tabindex="-1"><a class="header-anchor" href="#缓存可以解决什么问题-他的缺点是什么" aria-hidden="true">#</a> 缓存可以解决什么问题？他的缺点是什么？</h2><h3 id="解决什么问题。" tabindex="-1"><a class="header-anchor" href="#解决什么问题。" aria-hidden="true">#</a> 解决什么问题。</h3><ul><li>减少不必要的网络传输，节约宽带（就是省钱）</li><li>更快的加载页面（就是加速）</li><li>减少服务器负载，避免服务器过载的情况出现。（就是减载）</li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><ul><li>占内存（有些缓存会被存到内存中）</li></ul><p>http缓存又分为两种缓存，<code>强制缓存</code>和<code>协商缓存</code><br>http缓存流程图<br><img src="'+d+`" alt="image.png"></p><h2 id="强制缓存" tabindex="-1"><a class="header-anchor" href="#强制缓存" aria-hidden="true">#</a> 强制缓存</h2><p>强制缓存，我们简称强缓存。<br>从强制缓存的角度触发，如果浏览器判断请求的目标资源有效命中强缓存，如果命中，则可以直接从内存中读取目标资源，无需与服务器做任何通讯。</p><h3 id="基于expires字段实现的强缓存" tabindex="-1"><a class="header-anchor" href="#基于expires字段实现的强缓存" aria-hidden="true">#</a> 基于Expires字段实现的强缓存</h3><p>在以前，我们通常会使用响应头的<code>Expires</code>字段去实现强缓存。<br>Expires字段的作用是，设定一个强缓存时间。在此时间范围内，则从内存（或磁盘）中读取缓存返回。<br>比如说将某一资源设置响应头为: Expires:new Date(&quot;2022-7-30 23:59:59&quot;)；<br>那么，该资源在 2022-7-30 23:59:59 之前，都会去本地的磁盘（或内存）中读取，不会去服务器请求。<br>但是，<strong>Expires已经被废弃了</strong>。对于强缓存来说，Expires已经不是实现强缓存的首选。</p><blockquote><p>Expires 判断强缓存是否过期的机制是: 获取本地时间戳，并对先前拿到的资源文件中的Expires字段的时间做比较。来判断是否需要对服务器发起请求。这里有一个巨大的漏洞：“如果我本地时间不准咋办？” 是的，Expires过度依赖本地时间，如果本地与服务器时间不同步，就会出现资源无法被缓存或者资源永远被缓存的情况。所以，Expires字段几乎不被使用了。现在的项目中，我们并不推荐使用Expires，强缓存功能通常使用 <code>**cache-control**</code> 字段来代替Expires字段。</p></blockquote><h3 id="基于cache-control实现的强缓存-代替expires的强缓存实现方法" tabindex="-1"><a class="header-anchor" href="#基于cache-control实现的强缓存-代替expires的强缓存实现方法" aria-hidden="true">#</a> 基于Cache-control实现的强缓存（代替Expires的强缓存实现方法）</h3><p><code>**Cache-control**</code> 这个字段在http1.1中被增加，Cache-control完美解决了Expires本地时间和服务器时间不同步的问题。是当下的项目中实现强缓存的最常规方法。<br><code>**Cache-control**</code> 的使用方法页很简单，只要在资源的响应头上写上需要缓存多久就好了，单位是秒</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">//往响应头中写入需要缓存的时间</span>
res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
    <span class="token string-property property">&#39;Cache-Control&#39;</span><span class="token operator">:</span><span class="token string">&#39;max-age=10&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图的意思就是，从该资源第一次返回的时候开始，往后的10秒钟内如果该资源被再次请求，则从缓存中读取。<br><img src="`+l+'" alt="image.png"></p><blockquote><p>Cache-Control:max-age=N，N就是需要缓存的秒数。从第一次请求资源的时候开始，往后N秒内，资源若再次请求，则直接从磁盘（或内存中读取），不与服务器做任何交互</p></blockquote><p>Cache-control 中因为max-age后面的值是一个滑动时间，<strong>从服务器第一次返回该资源时开始倒计时</strong>。所以也就不需要比对客户端和服务端的时间，解决了Expires所存在的巨大漏洞</p><h3 id="cache-control-的属性" tabindex="-1"><a class="header-anchor" href="#cache-control-的属性" aria-hidden="true">#</a> Cache-control 的属性</h3><p>Cache-control有max-age、s-maxage、no-cache、no-store、private、public这六个属性。<br><code>**max-age**</code> 决定客户端资源被缓存多久。<br><code>**s-maxage**</code> 决定代理服务器缓存的时长。<br><code>**no-cache**</code> 表示是强制进行协商缓存。<br><code>**no-store**</code> 是表示禁止任何缓存策略。<br><code>**public**</code> 表示资源即可以被浏览器缓存也可以被代理服务器缓存。<br><code>**private**</code> 表示资源只能被浏览器缓存。</p><h4 id="no-cache-和-no-store" tabindex="-1"><a class="header-anchor" href="#no-cache-和-no-store" aria-hidden="true">#</a> no-cache 和 no-store</h4><p><code>**no_cache**</code>是 Cache-control的一个属性。它并不像字面意思一样禁止缓存，实际上，no-cache的意思是<strong>强制进行协商缓存</strong>。<br>如果某一资源的Cache-control中设置了no-cache，那么该资源会直接跳过强缓存的校验，直接去服务器进行协商缓存。而 <code>**no-store**</code>** <strong>就是</strong>禁止所有的缓存策略**了。</p><blockquote><p>注意，no-cache和no-store是一组互斥属性，这两个属性不能同时出现在 <code>**Cache-Control**</code> 中。</p></blockquote><h4 id="public和private" tabindex="-1"><a class="header-anchor" href="#public和private" aria-hidden="true">#</a> public和private</h4><p>一般请求是从客户端直接发送到服务端，如下↓<br><img src="'+h+'" alt="image.png"><br>但有些情况下是例外的：比如，出现代理服务器，如下↓<br><img src="'+b+'" alt="image.png"><br>而public和private就是决定资源<strong>是否可以在代理服务器进行缓存的属性</strong>。<br>其中，<strong>public表示资源在客户端和代理服务器都可以被缓存</strong>。<br><strong>private则表示资源只能在客户端被缓存，拒绝资源在代理服务器缓存</strong>。<br>如果这两个属性值都没有被设置，则<strong>默认为private</strong></p><blockquote><p>注意，public和private也是一组互斥属性。他们两个不能同时出现在响应头的<code>** Cache-Control**</code>** **字段中。</p></blockquote><h4 id="max-age和s-maxage" tabindex="-1"><a class="header-anchor" href="#max-age和s-maxage" aria-hidden="true">#</a> max-age和s-maxage</h4><p>max-age表示的时间资源在客户端缓存的时长，而s-maxage表示的是资源在代理服务器可以缓存的时长。<br>在一般的项目架构中max-age就够用。<br>而s-maxage因为是代理服务端的缓存时长，他必须和上面说的public属性一起使用（public属性表示资源可以在代理服务器中缓存）。</p><blockquote><p>max-age和s-maxage并不互斥。他们可以一起使用。</p></blockquote><h4 id="cache-control如何设置" tabindex="-1"><a class="header-anchor" href="#cache-control如何设置" aria-hidden="true">#</a> Cache-control如何设置</h4><p>Cache-control如何设置多个值呢？用逗号分割，如下<br><code>Cache-control:max-age=10000,s-maxage=200000,public</code></p><blockquote><p>强制缓存就是以上这两种方法了。现在我们回过头来聊聊，Expires难道就一点用都没有了吗？ 也不是，虽然Cache-control是Expires的完全替代品，但是如果要考虑向下兼容的话，在Cache-control不支持的时候，还是要使用Expires， 这也是我们当前使用的这个属性的唯一理由。</p></blockquote><h2 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a> 协商缓存</h2><h3 id="协商缓存是什么" tabindex="-1"><a class="header-anchor" href="#协商缓存是什么" aria-hidden="true">#</a> 协商缓存是什么</h3><p><img src="'+g+'" alt="image.png"></p><p>使用以上方式的协商缓存已经存在两个非常明显的漏洞。这两个漏洞都是基于文件是通过比较修改时间来判断是否更改而产生的。<br>1.因为是更具文件修改时间来判断的，所以，在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来），这样，就有可能文件内容明明没有修改，但是缓存依然失效了。<br>2.当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会<br>返回新的文件。</p><h3 id="基于last-modified的协商缓存" tabindex="-1"><a class="header-anchor" href="#基于last-modified的协商缓存" aria-hidden="true">#</a> 基于last-modified的协商缓存</h3><p>基于last-modified的协商缓存实现方式是:</p><ul><li>首先需要在服务器端读出文件修改时间，</li><li>将读出来的修改时间赋给响应头的last-modified字段。</li><li>最后设置Cache-control:no-cache</li></ul><p>三步缺一不可。<br>如下图↓<br><img src="'+u+'" alt="image.png"></p><p>第一行，读出修改时间。<br>第二行，给该资源响应头的last-modified字段赋值修改时间<br>第三行，给该资源响应头的Cache-Control字段值设置为:no-cache.(上文有介绍，Cache-control:no-cache的意思是跳过强缓存校验，直接进行协商缓存。)<br>还没完。到这里还无法实现协商缓存<br>当客户端读取到last-modified的时候，会在下次的请求标头中携带一个字段:<code>If-Modified-Since</code>。</p><p><img src="'+m+'" alt="image.png"></p><p>这个请求头中的<code>If-Modified-Since</code>就是服务器第一次修改时候给他的时间，也就是上图中的<br><code>res.setHeader(&#39;last-modified&#39;, mtime.toUTCString())</code></p><p><strong>那么之后每次对该资源的请求，都会带上If-Modified-Since这个字段，而务端就需要拿到这个时间并再次读取该资源的修改时间，让他们两个做一个比对来决定是读取缓存还是返回新的资源。</strong><br><img src="'+x+'" alt="image.png"></p><h3 id="基础etag的协商缓存" tabindex="-1"><a class="header-anchor" href="#基础etag的协商缓存" aria-hidden="true">#</a> 基础ETag的协商缓存</h3><p><strong>ETag(Entity 实体标签)</strong><br>ETag就是将原先协商缓存的比较时间戳的形式修改成了比较文件指纹。</p><blockquote><p>文件指纹:根据文件内容计算出的唯一哈希值。文件内容一旦改变则指纹改变。</p></blockquote><p>流程↓<br>1.第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在<strong>响应头的etag字段</strong>中跟资源一起返回给客户端。<br>2.第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的ETag也就是文件指纹。并赋给请求头的<code>**if-None-Match**</code>字段，让上一次的文件指纹跟随请求一起回到服务端。<br>3.服务端拿到请求头中的is-None-Match字段值（也就是上一次的文件指纹），并再次读取目标资源并生成文件指纹，两个指纹做对比。如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回304状态码和一个空的响应体并return。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的ETag中并返回给客户端<br>代码示例：<br><img src="'+f+'" alt="image.png"><br>流程示例图↓<br><img src="'+_+'" alt="image.png"></p><blockquote><p>从校验流程上来说，协商缓存的修改时间比对和文件指纹比对，几乎是一样的。</p></blockquote><h3 id="etag也有缺点" tabindex="-1"><a class="header-anchor" href="#etag也有缺点" aria-hidden="true">#</a> ETag也有缺点</h3><ul><li>ETag需要计算文件指纹这样意味着，服务端需要更多的计算开销。。如果文件尺寸大，数量多，并且计算频繁，那么ETag的计算就会影响服务器的性能。显然，ETag在这样的场景下就不是很适合。</li><li>ETag有强验证和弱验证，所谓将强验证，ETag生成的哈希码深入到每个字节。哪怕文件中只有一个字节改变了，也会生成不同的哈希值，它可以保证文件内容绝对的不变。但是，强验证非常消耗计算量。ETag还有一个弱验证，弱验证是提取文件的部分属性来生成哈希值。因为不必精确到每个字节，所以他的整体速度会比强验证快，但是准确率不高。会降低协商缓存的有效性。</li></ul><blockquote><p>不同于cache-control是expires的完全替代方案 (说人话:能用cache-control就不要用expiress)， ETag并不是last-modified的完全替代方案。而是last-modified的补充方案 (说人话：项目中到底是用ETag还是last-modified完全取决于业务场景，这两个没有谁更好谁更坏)。</p></blockquote><h2 id="如何设置缓存" tabindex="-1"><a class="header-anchor" href="#如何设置缓存" aria-hidden="true">#</a> 如何设置缓存</h2><p><strong>从前端的角度来说:</strong><br>你什么都不用干，缓存是缓存在前端，但实际上代码是后端的同学来写的。如果你需要实现前端缓存的话啊，通知后端的同学加响应头就好了。<br><strong>从后端的角度来说</strong><br>请参考文章，虽然文章里的后端是使用node.js写的，但我写了详细的注释。对于后端的同学来说。应该不难看懂。</p><h2 id="哪些文件对应哪些缓存" tabindex="-1"><a class="header-anchor" href="#哪些文件对应哪些缓存" aria-hidden="true">#</a> 哪些文件对应哪些缓存</h2><p>有哈希值的文件设置强缓存即可。<br>没有哈希值的文件（比如index.html）设置协商缓存</p><blockquote><p>哈希值是需要webpack生成的。不是天生的。不过有些框架会自带（比如我使用的umi.js）,设置缓存前务必看下自己的dist文件。因为如果没有配置的话，你可能所有文件都不带哈希值。</p></blockquote><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>',64),C=a("<li><p>http缓存可以减少宽带流量，加快响应速度。</p></li><li><p>关于强缓存，<code>cache-control</code>是Expires的完全替代方案，在可以使用cache-control的情况下不要使用expires</p></li><li><p>关于协商缓存,<code>etag</code>并不是<code>last-modified</code>的完全替代方案，而是补充方案，具体用哪一个，取决于业务场景。</p></li><li><p>有些缓存是从磁盘读取，有些缓存是从内存读取，有什么区别？答：从内存读取的缓存更快。</p></li><li><p>所有带304的资源都是协商缓存，所有标注（从内存中读取/从磁盘中读取）的资源都是强缓存。</p></li>",5),q=e("p",null,"参考文章",-1),v={href:"https://juejin.cn/post/7127194919235485733",target:"_blank",rel:"noopener noreferrer"};function T(N,w){const o=c("ExternalLinkIcon");return t(),n("div",null,[E,e("ul",null,[C,e("li",null,[q,e("ul",null,[e("li",null,[e("a",v,[s("中高级前端工程师都需要熟悉的技能--前端缓存 - 掘金"),i(o)])])])])])])}const M=r(k,[["render",T],["__file","cache.html.vue"]]);export{M as default};
